<h1 id="insertion-sort-in-python">Insertion Sort in Python</h1>

<p><a href="https://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a> is type of <a href="https://en.wikipedia.org/wiki/Sorting_algorithm">sorting algorithm</a> that is relatively simple to implement. It does not have the best runtime, i.e. <code class="highlighter-rouge">O(n^2)</code>, compared to more advanced sorting algorithms such as <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a> or <a href="https://en.wikipedia.org/wiki/Merge_sort">merge sort</a> but is a good starting sorting algorithm to learn. It can be used to sort smaller arrays consisting of strings or numbers.</p>

<h2 id="pseudocode">Pseudocode</h2>

<p>Here is the pseudocode of insertion code (from <a href="https://en.wikipedia.org/wiki/Insertion_sort#Algorithm">wikipedia</a>):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>i ← 1
while i &lt; length(A)
    j ← i
    while j &gt; 0 and A[j-1] &gt; A[j]
        swap A[j] and A[j-1]
        j ← j - 1
    end while
    i ← i + 1
end while
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The general idea behind it is to iterate through the array from beginning to end and swaps each element from the current element to the beginning of the array if a “greater” prior element is found compare to the current element. It basically sorts “subsections” of the array repeatedly until the entire array is sorted by “inserting” new elements in the right order in the subsection of the array.</p>

<h2 id="python-implementation">Python Implementation</h2>

<p>Without further ado, here is my Python (3) implementation of it:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="c1"># swap the two array elements
</span>            <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">array</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As you can see, it closely follows the pseudocode, with some minimal code savings using the <code class="highlighter-rouge">range</code> function. The <code class="highlighter-rouge">swap</code> was implemented inline but could be implemented as a separate function as well.</p>

<h2 id="runtime">Runtime</h2>

<p>As mentioned, the average runtime for this algorithm is <code class="highlighter-rouge">O(n^2)</code>. The best case is an array that is already sorted with a runtime of <code class="highlighter-rouge">O(n)</code> as the current element in the array will only be compared once with a prior element. The worst case is an array that is sorted in reverse as each new element will need to be compared (and swapped) with every prior element to the beginning of the array.</p>

<p>Thanks for reading, any comment or feedback is most welcome!</p>
