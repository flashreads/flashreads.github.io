<h1 id="generators-and-iterators-in-python">Generators and Iterators in Python</h1>

<p>Generator functions allow us to write a function that can send back a value and then later resume to pick up where it left off. This type of function is a generator in Python, allowing us to generate a sequence of values over time. The main difference in syntax will be the use of a yield statement.</p>

<p>In most aspects, a generator function will appear very similar to a normal function. The main difference is when a generator function is compiled they become an object that supports an iteration protocol. That means when they are called in your code they don’t actually return a value and then exit. Instead, generator functions will automatically suspend and resume their execution and state around the last point of value generation</p>

<p>￼￼ To start getting a better understanding of generators, let’s go ahead and see how we can create some.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="c1"># Generator function for the cube of numbers (power of 3)
</span><span class="k">def</span> <span class="nf">gencubes</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">num</span><span class="o">**</span><span class="mi">3</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gencubes</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Generators are best for calculating large sets of results (particularly in calculations that involve loops themselves) in cases where we don’t want to allocate the memory for all of the results at the same time.</p>

<p>Let’s create another example generator which calculates fibonacci numbers:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="c1"># Generator function for the cube of numbers (power of 3)
</span><span class="k">def</span> <span class="nf">genfibon</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="s">"""
    Generate a fibonnaci sequence up to n
    """</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">a</span>
        <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span>

<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">genfibon</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="next-built-in-function-in-python">next() built-in function in Python</h2>
<p>A key to fully understanding generators is the next() function and the iter() function.</p>

<p>The next() function allows us to access the next element in a sequence. Lets check it out:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c1"># Generator function for the cube of numbers (power of 3)
</span><span class="k">def</span> <span class="nf">simple_gen</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">x</span>

<span class="c1"># Assign simple_gen 
</span><span class="n">g</span> <span class="o">=</span> <span class="n">simple_gen</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="c1">#prints out a value in the generator
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="iter-built-in-fuction-in-python">iter() built-in Fuction in Python</h2>
<p>Let’s go ahead and check out how to use iter()
 A string object supports iteration, We can directly iterate over a string with The iter() function.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="n">s</span> <span class="o">=</span> <span class="s">'hello'</span>

<span class="c1">#Iterate over string
</span><span class="k">for</span> <span class="n">let</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">let</span><span class="p">)</span>

<span class="n">s_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="nb">next</span><span class="p">(</span><span class="n">s_iter</span><span class="p">)</span> <span class="c1"># print each of the value in s when called 
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>The main takeaway from this article is that using the yield keyword at a function will cause the function to become a generator. This change can save you a lot of memory for large use cases.</p>
