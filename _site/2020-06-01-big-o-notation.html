<p>Let’s preview the following simple fucntion:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># note that := is assignment operator avaiable in Python 3.8
</span>    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">[</span><span class="nb">sum</span> <span class="p">:</span><span class="o">=</span> <span class="nb">sum</span> <span class="o">+</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sum</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Can you count the steps that are needed before returning the sum? Assigning the 0 value to sum, iterate over each <code class="highlighter-rouge">n</code> element and add it to the sum and lastly return the sum. Is there some mathematical notation that can describe this? Yes, that is the Big O notation. You can simply describe the efficiency of the algorithm with Big O notation. The Big O notation is used to describe the complexity of an algorithm according to the run time and space requirements when the different input size is used. Let me show you how it might look with code.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">find_awesome_user</span><span class="p">(</span><span class="n">users</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">users</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">city</span> <span class="o">==</span> <span class="s">'awesome city'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">user</span>
    <span class="k">return</span> <span class="s">'Not found'</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Before we found the user from an <code class="highlighter-rouge">awesome city</code> some number of checks must be performed. The user that we are looking can be the last in the list so we need to iterate through all of them which would be the worst-case scenario. Finding the user from the <code class="highlighter-rouge">awesome city</code> on the first iteration would be our best-case scenario. If we have the 50 users our average case scenario would fall somewhere in the middle, around 25 users. So, by analyzing the time complexity of the above function you can think of the best, average and worst-case scenarios. Big O notation measures the worst-case scenario. You can describe the complexity of this function as a linear because of the steps required to complete the execution of the function increase or decrease linearly with the number of users. You can say that the efficiency of the function is about O(n).</p>

<p>Sometimes, an algorithm needs to perform a linear time operation for each value in the input data for e.g</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>In this case, it is a quadratic time complexity O(n2).</p>

<p>But what if the function doesn’t depend on the input data? In that case, we can say that it has a constant time O(1).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">find_first</span><span class="p">(</span><span class="n">users</span><span class="p">):</span>
    <span class="c1">#imagine the users were sorted by id
</span>    <span class="k">return</span> <span class="n">users</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>This function doesn’t depend on the input data size, because it always gets the first user from the list.</p>

<p>By looking at the above examples maybe you can think of a use case where some algorithm has multiple complexities e.g O(n) + O(n2) + O(n!) etc. So, how can you calculate them, is just by describing the largest complexity of that algorithm. In the above example as O(n!) which is a factorial time complexity that grows in a factorial way.</p>

<p><img src="https://lukasmestan.com/assets/images/big-o-all.png" alt="Big O Complexity chart" /></p>

<p>For additional information on the Big O complexity of most common algorithms in the computer science check <a href="https://www.bigocheatsheet.com/">bigocheatsheet</a>.</p>
